\section*{Progress}

As detailed in the inception report, the original plan was to have two complete iterations by the 05/11 and 12/11 respectively. In practice, we completed one iteration which combined the tasks for both iterations by 12/11. Referring back the the inception report, our program was to be implemented only for the restricted language of $\mathcal{AL}$. Only in the second iteration, where we to extend the systems functionality to deal with the more expressive $\mathcal{ALC}$ logic. After discussing the matter with our supervisor we found the difference in implementation is relatively minor. In particular, the main difference is the fact that $\mathcal{ALC}$ allows for any concept negation whereas $\mathcal{AL}$ only allows atomic concept negation. This, both in the implementation and testing sides, was a relatively small addition and required little effort. We therefore decided on producing one iteration which would ultimately achieve a combined result of the first and second iterations, i.e a program that deals with all $\mathcal{ALC}$ (rather then $\mathcal{AL}$) concepts.

We completed the requirements for that first first iteration. We firstly produced a representation for concepts, models and proofs for $\mathcal{ALC}$ logic (that we made as extensible as possible for other description logics as we can think of at this stage) as haskell data types. We also produced an algorithm for proof and model searching as well as a proof checker and a model checker for $\mathcal{ALC}$ logic. We produced separate testing suits, for unit testing (using Hunit) for all of the above implementations. However, as correctness is critical for this project, we will constantly update these files and add additional tests for the functionality of these programs in more complicated cases.  

At times we found that it was difficult to meet the requirements and tasks issued to each member in the exact deadline set internally and we had to adjust this deadline. We managed to quickly resolve these issues, mainly due to the frequent meeting we have (as part of our development method). We found, as expected, that in this iteration a lot of work was carried to have a fully functional program solving the high risks elements of our project. This, at times, meant that other work was pushed aside, and frequent internal deadlines helped as achieve high productivity, with each member expected to finish his part on time. A potential problem that may incur is that the current test suits may not provide sufficient testing for the program to make sure it is completely correct. For this reason, we will constantly update the test suits in subsequent iterations.

% SHOULD WE PERHAPS INCLUDE FORMAL REASONING