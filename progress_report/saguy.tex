As detailed in the inception report, the original plan was to have two complete iterations by the 05/11 and 12/11 respectively. In practice, we completed one iteration which combined the tasks for both iterations by 12/11. We intended to write a program that deals only for the restricted language of $\mathcal{AL}$ (A particular description logic). Only in the second iteration, where we to extend the systems functionality to deal with the more expressive $\mathcal{ALC}$ logic. However, we found that a vast amount of refactoring and redesign will be required, if we were to move from $\mathcal{AL}$ to $\mathcal{ALC}$ in the second iteration.  We agreed that,  both in the implementation and testing sides, it would be wise produce one iteration which would ultimately achieve a combined result of the first and second iterations, i.e a program that deals with all $\mathcal{ALC}$ (rather then $\mathcal{AL}$) concepts.  

We managed to finish the first iteration as planed. In particular, the following tasks were completed:

\begin{itemize}
\item Representation of concepts, models and proofs from $\mathcal{ALC}$ logic as Haskell data types. These were made as extensible as possible for other description logics that we could think of at this stage. 
\item Implementation of a model/proof searching algorithm for $\mathcal{ALC}$. The algorithm itself is correct for all cases for which it terminates (As described later in report, we will deal with non-termination in a later iteration). 100\% correctness is difficult to achieve and so we assume correctness for the program when it passes all tests in its corresponding test suit (see below point). 
\item Implementation of a model checking algorithm for $\mathcal{ALC}$ that checks if a model is correct and additionally provides an error report if the model is incorrect.
\item Implementation of a proof checking algorithm for $\mathcal{ALC}$ that checks if a proof is correct and additionally provides an indication of the position where the proof is incorrect if it is incorrect. 
\item A simple standard output format for generated models and proofs (for use by proof checker and model checker). 
\item Additionally, we provided complete test suits, which include unit tests for the proof/model search, proof checker and model checker. The test suits were implemented in multiple levels. In the first level, a set of simple tests for all of  the base cases was developed. In the second level,  more elaborate tests were made testing of a combination of simple inputs and in the last level, a random selection of complex inputs was tested.  
\end{itemize} 

At times we found that it was difficult to meet all of the requirements in the exact deadline set internally and we had to adjust this deadline. However, we managed to quickly resolve any issues, mainly due to the frequent meetings we have (as part of our development method) that were set every Monday and  Friday as well as a weekly meeting with our supervisor. The main difficulty we had was to get the test suits completed  and to coordinate the activities together by Monday 08/11. The meeting on Monday 08/11 helped us clarify the remaining tasks and redistribute them (who much and who does what tests). We finished both of these remaining tasks on Thursday 11/11 as agreed in the meeting. In addition, we found, as expected, that in this iteration a lot of work was carried to have a fully functional program solving the high risks elements of our project. This, at times, meant that other work was pushed aside; and frequent internal deadlines helped us achieve high productivity, with each member expected to finish his/her part on time. 

% SHOULD WE PERHAPS INCLUDE FORMAL REASONING
