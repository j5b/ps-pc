{- 
   Author: Ka Wai Cheng
   Maintainer: Ka Wai Cheng
   Email: <mail.kawai.cheng@gmail.com>
   License: GPL 3.0
   File: ProofChecker_test.hs
   Description: tests for ProofChecker.hs
-}

module ProofChecker_test where 

import Signature
import Proof
import ProofChecker
import ProofUtils
import TestUtils

import Test.HUnit

bottomStepTests = maplabel "bottom tree test" [btest1, btest2, btest3]

existsStepTests = maplabel "exists tree test" [etest1, etest2, etest3]

andStepTests =  maplabel "and tree test" [atest1, atest2, atest3]

orStepTests = maplabel "or tree test" [otest1, otest2, otest3]

allproofsteptest = do putStrLn "==== Testing the proof step function"
                      runTestTT bottomStepTests
                      runTestTT existsStepTests
                      runTestTT andStepTests
                      runTestTT orStepTests

leafTests = maplabel "leaf test" [leaftest1, leaftest2, leaftest3, leaftest4]

simpleTreeTests = maplabel "simple tree test" [btreetest1, btreetest2,
                                               atreetest1, atreetest2,
                                               otreetest1, otreetest2,
                                               etreetest1, etreetest2]

treeTests = maplabel "tree test" [treetest1, treetest2]

alltreetests = do putStrLn "==== Testing the trees generated by proof searcher"
                  runTestTT leafTests
                  runTestTT simpleTreeTests
                  runTestTT treeTests

checkProofTests = maplabel "proof test" [prooftest1, prooftest2, prooftest3,
                                         prooftest4, prooftest5, prooftest6]

allproofcheckertests = do putStrLn "==== Testing the proof checker"
                          runTestTT checkProofTests

-- Testing setup

bConcept, aConcept, oConcept, eConcept, fConcept :: Concept
bConcept = notatoma
aConcept = a_and_b
oConcept = c_or_d
eConcept = Exists "R" (Atom "E")
fConcept = Forall "R" (Atom "F")

manyConcepts, gamma :: [Concept]
manyConcepts = [bConcept, aConcept, oConcept, eConcept, fConcept]
gamma = [Atom "U", Neg (Atom "U"), And (Atom "V") (Atom "W"),
         Or (Atom "X") (Atom "Y"), Forall "R" (Atom "Z")]

bTree = NodeZero ([atoma, notatoma], bRule, atoma)
aTree = NodeOne ([aConcept, notatoma], aRule, aConcept)
		(NodeZero ([atoma, atomb, notatoma], bRule, atoma))
oTree = NodeTwo ([oConcept, notatomc, notatomd], oRule, oConcept)
		(NodeZero ([atomc, notatomc, notatomd], bRule, atomc))
		(NodeZero ([atomd, notatomc, notatomd], bRule, atomd))
eTree1 = NodeOne ([Forall "R" (notatoma), eConcept, forall_r_a,
                  Forall "S" (atomb)], eRule, eConcept)
         (NodeZero ([atoma, Atom "E", notatoma], bRule, atoma))
-- etree with gamma
eTree2 = NodeOne ([Forall "R" (notatoma), eConcept, forall_r_a,
                  Forall "S" (atomb)], eRule, eConcept)
         (NodeZero ([atoma, Atom "E", notatoma, Atom "N"],
          bRule, atoma))

-- With gamma
tree :: ProofTree
tree = NodeOne (manyConcepts ++ gamma , eRule, eConcept)
        (NodeTwo ([Atom "E", Atom "F", Atom "Z"] ++ gamma, oRule,
         Or (Atom "X") (Atom "Y"))
          (NodeZero ([Atom "X", Atom "E", Atom "F", Atom "Z", Atom "U",
           Neg (Atom "U"), And (Atom "V") (Atom "W"), Forall "R" (Atom "Z")],
           bRule, Atom "U"))
          (NodeOne ([Atom "Y", Atom "E", Atom "F", Atom "Z", Atom "U",
           Neg (Atom "U"), And (Atom "V") (Atom "W"), Forall "R" (Atom "Z")],
           aRule, And (Atom "V") (Atom "W"))
            (NodeZero ([Atom "V", Atom "W", Atom "Y", Atom "E", Atom "F",
             Atom "Z", Atom "U", Neg (Atom "U"), Forall "R" (Atom "Z")],
             bRule, Atom "U"))))

-- Tests for checkProofStep
btest1 = testequality msg target result "{A, Not A}"
  where msg    = "Failed to correctly apply the bottom rule to {A, Atom A}"
        result = checkProofStep ([atoma, bConcept], bRule, atoma) []
        target = ("", True, [])

btest2 = testequality msg target result "{A, Not B}"
  where msg    = "Failed to show Not A does not exist in applying bottom rule"
        result = checkProofStep ([notatomb, atoma], bRule, atoma) gamma
        target = ("Atom A and Not (Atom A) do not both exist in the set of"
                  ++ " concepts {Not (Atom B), Atom A}", False,
                  [[notatomb, atoma]])

btest3 = testequality msg target result "{A, Not A}"
  where msg    = "Failed to correctly apply bottom rule with nonempty gamma"
        result = checkProofStep ([atoma, bConcept], bRule, atoma) gamma
        target = ("", True, [])

atest1 = testequality msg target result "{A and B} with empty gamma"
  where msg    = "Failed to correctly apply the and rule to A and B"
        result = checkProofStep ([aConcept], aRule, aConcept) []
        target = ("", True, [[atoma, atomb]])

atest2 = testequality msg target result "{C and D} with non-empty gamma"
  where msg    = "Failed to show A and B does not exist in applying and rule"
        result = checkProofStep ([c_and_d], aRule, aConcept) []
        target = ("(Atom A and Atom B) does not exist in the set of " ++
                  "concepts {(Atom C and Atom D)}", False, [[c_and_d]])

atest3 = testequality msg target result "{A and B} with non-empty gamma"
  where msg    = "Failed to correctly apply the and rule to A and B"
        result = checkProofStep ([aConcept], aRule, aConcept) gamma
        target = ("", True, [[atoma, atomb]])


otest1 = testequality msg target result "{C or D} with empty gamma"
  where msg    = "Failed to correctly apply the or rule to C or D"
        result = checkProofStep ([oConcept, bConcept], oRule, oConcept) []
        target = ("", True, [[atomc, bConcept], [atomd, bConcept]])

otest2 = testequality msg target result "{C or D} with non-empty gamma"
  where msg    = "Failed to show A or B does not exist in applying the or rule"
        result = checkProofStep ([oConcept], oRule, Or (atoma) (atomb)) gamma
        target = ("(Atom A or Atom B) does not exist in the set of " ++
                  "concepts {(Atom C or Atom D)}", False, [[oConcept]])

otest3 = testequality msg target result "{C or D, not B} with non-empty gamma"
  where msg    = "Failed to correctly apply the or rule to C or D"
        result = checkProofStep ([oConcept, bConcept], oRule, oConcept) gamma
        target = ("", True, [[atomc, bConcept], [atomd, bConcept]])

etest1 = testequality msg target result ("{Exists R.A, Forall R.B, " ++
         "Forall S.C} with empty gamma")
  where msg    = "Failed to correctly apply the exists rule to Exists R.A"
        result = checkProofStep ([exists_r_a, forall_r_b, forall_s_c],
                 eRule, exists_r_a) []
        target = ("", True, [[atoma, atomb]])

etest2 = testequality msg target result "{Exists R.A} with non-empty gamma"
  where msg    = "Failed to show Exists R.A doesn't exist in applying exists rule"
        result = checkProofStep ([exists_r_a], eRule, exists_r_b) gamma
        target = ("(Exists R Atom B) does not exist in the set of " ++
                  "concepts {(Exists R Atom A)}", False, [[exists_r_a]])

etest3 = testequality msg target result ("{Exists R.A, Forall R.B, Forall " ++
         "S.C} with non-empty gamma")
  where msg    = "Failed to correctly apply the exists rule to Exists R.A"
        result = checkProofStep ([exists_r_a, forall_r_b, forall_s_c],
                 eRule, exists_r_a) gamma
        target = ("", True, [[atoma, atomb] ++ gamma])


-- Tests for checkTree
leaftest1 = testequality msg target result "{Neg T} proof tree with empty gamma"
  where msg    = "Failed to correctly check 1 node proof tree"
        result = checkTree (NodeZero ([Neg T], "", Neg T)) []
        target = ("", True)

leaftest2 = testequality msg target result "Proof tree ending with Atom A"
  where msg    = "Failed to show 1 node proof tree does not show unsatisfiability"
        result = checkTree (NodeZero ([atoma], "", atoma)) gamma
        target = ("This proof tree does not show unsatisfiability", False)

leaftest3 = testequality msg target result ("Proof tree with last node as " ++
            "and rule applied to step A and B")
  where msg    = "Failed to show last step in proof tree should have a successor"
        result = checkTree (NodeZero ([aConcept], aRule, aConcept)) gamma
        target = ("Proof tree is not complete, applying the and rule to {" ++
                  "(Atom A and Atom B)} produces {Atom A, Atom B}", False)

leaftest4 = testequality msg target result "{Neg T} proof tree with non-empty gamma"
  where msg    = "Failed to correctly check 1 node proof tree"
        result = checkTree (NodeZero ([Neg T], "", Neg T)) gamma
        target = ("", True)

btreetest1 = testequality msg target result "{Neg T} proof tree with empty gamma"
  where msg    = "Failed to correctly check proof tree containing bottom rule"
        result = checkTree bTree []
        target = ("", True)

btreetest2 = testequality msg target result ("Proof tree with extra node " ++
             "after applying bottom rule")
  where msg    = "Failed to show there should be no resulting set of concepts"
        result = checkTree (NodeOne ([bConcept, atoma], bRule, atoma)
                 (NodeZero ([bottom], "", bottom))) []
        target = ("Applying the bottom rule to {Not (Atom A), Atom A} should"
                  ++ " not give 1 resulting set of concepts", False)

atreetest1 = testequality msg target result "{A and B} proof tree with empty gamma"
  where msg    = "Failed to correctly check proof tree containing and rule"
        result = checkTree aTree []
        target = ("", True)

atreetest2 = testequality msg target result "{Neg T} proof tree with empty gamma"
  where msg    = "Failed to show result of proof step do not match next " ++
                 "nodes' set of concepts after applying and rule"
        result = checkTree (NodeOne ([aConcept, bConcept], aRule, aConcept)
                 (NodeZero ([atoma, notatomb], bRule, atomb))) []
        target = ("Next step's concepts {Atom A, Not (Atom B)} do not match" ++
                  " the result of applying and rule to {(Atom A and Atom B)" ++
                  ", Not (Atom A)}", False)

otreetest1 = testequality msg target result "{C or D} proof tree with empty gamma"
  where msg    = "Failed to correctly check proof tree containing or rule"
        result = checkTree oTree []
        target = ("", True)

otreetest2 = testequality msg target result "{A and B} proof tree with empty gamma"
  where msg    = "Failed to show there cannot be 2 results by applying and rule"
        result = checkTree (NodeTwo ([aConcept, bConcept], aRule, aConcept)
                 (NodeZero ([atoma, bConcept], bRule, atoma))
                 (NodeZero ([atoma, bConcept], bRule, atoma))) []
        target = ("Applying the and rule to {(Atom A and Atom B), Not (Atom" ++
                  " A)} should not give 2 resulting sets of concepts", False)

etreetest1 = testequality msg target result ("{Exists R.E, Forall R.Not A, " ++
             "Forall R.A, Forall S.B} proof tree with empty gamma")
  where msg    = "Failed to correctly check proof tree containing exists rule"
        result = checkTree eTree1 []
        target = ("", True)

etreetest2 = testequality msg target result ("{Exists R.E, Forall R.Not A, " ++
             "Forall R.A, Forall S.B} proof tree with gamma {N}")
  where msg    = "Failed to correctly check proof tree containing exists " ++
                 "rule and non-empty gamma"
        result = checkTree eTree2 [Atom "N"]
        target = ("", True)

treetest1 = testequality msg target result ("More complex proof tree with " ++
            "non-empty gamma")
  where msg    = "Failed to correctly check a more complex proof tree"
        result = checkTree tree gamma
        target = ("", True)

treetest2 = testequality msg target result ("{A, Not B} proof tree with " ++
            "non-empty gamma")
  where msg    = "Failed to show there is an invalid proof step in a proof tree"
        result = checkTree (NodeZero ([notatomb, atoma], bRule, atoma)) gamma
        target = ("Atom A and Not (Atom A) do not both exist in the set of " ++
                  "concepts {Not (Atom B), Atom A}", False)

-- Tests for checkProof
prooftest1 = testequality msg target result ("Proof tree showing " ++
             "unsatisfiability with non-empty gamma")
  where msg    = "Failed to correctly check proof is correct"
        result = checkProof tree gamma
        target = ("", True)

prooftest2 = testequality msg target result ("Proof with duplicated concept" ++
             " (A and B)")
  where msg    = "Failed to show there are duplicates in the initial set of " ++
                 "concepts in the proof"
        result = checkProof (NodeZero ([aConcept, aConcept], "", aConcept)) [atoma]
        target = ("Initial concepts must not contain duplicate concepts", False)

prooftest3 = testequality msg target result ("Proof with duplicated concept" ++
             " (A and B) in gamma")
  where msg    = "Failed to show there are duplicates in gamma provided"
        result = checkProof tree [atoma, atoma]
        target = ("Gamma must not contain duplicate concepts", False)

prooftest4 = testequality msg target result ("Proof with a concept not in " ++
             "negation normal form Not(A and B)")
  where msg    = "Failed to show concepts in the proof are not in negation " ++ 
                 "normal form"
        result = checkProof (NodeZero ([Neg T, Neg aConcept], "", Neg T)) gamma
        target = ("Initial concepts are not in negation normal form", False)

prooftest5 = testequality msg target result ("Proof with a concept not in " ++
             "negation normal form Not(A and B) in gamma")
  where msg    = "Failed to show concepts in gamma are not in negation normal form"
        result = checkProof tree [Neg aConcept]
        target = ("Concepts in gamma are not in negation normal form", False)

prooftest6 = testequality msg target result ("Proof that does not contain a" ++
             " concept (Atom P) from gamma in the inital set of concepts")
  where msg    = "Failed to show concepts in gamma are not in the initial " ++
                 "set of concepts in the proof"
        result = checkProof tree [Atom "P"]
        target = ("Concepts in gamma are not in the initial set of concepts", False)
