As indicated in the inception report, a test-driven development method was adopted; hence unit testing was done at all stages of development. Unit tests were written before the implementation of functions or simultaneously; and test suites are run regularly, especially after any changes to code, to ensure the program still works as expected. All areas of code were tested in this way individually: model/proof construction; model checking; proof checking; parsing of user input and test files; and the outputting of the constructed proof and model.

\subsection*{Benefits}
Although writing an extensive set of unit tests that cover all possible cases take almost as much time as implementing the code itself, there were many benefits from this approach.

By simultaneously writing the unit tests, it helped programmers think about and have a clear view of the expected/desired output of functions. This made coding of functions easier and members were able to identify mistakes quickly. Most of the time, bugs were found as the functions were implemented and were therefore corrected immediately.

When moving on to code other parts of the program, we have confidence that tested code is correct and produces expected results when given expected inputs. As a result, we were able to highlight differences in expectations between members writing different parts of the program for discussion in our meetings and come to an agreed solution.

Unit tests were written for code coverage, ensuring all input cases were considered and our code produces the expected results. Otherwise, unit testing exposed where cases were not handled correctly. This helped identify most bugs early on, before code became more complex and difficult to resolve.

In particular, having extensively tested proof checker and model checker by unit tests enabled these components of the program to be used with high confidence in other types of testing. The proof and model checkers are important in these other tests to check the results produced, for the automatically generated complex input cases, by the proof and model construction part of the program, which is very complicated and much harder to test simply by unit tests due to its exploratory nature.

\subsection*{Bugs}
The bugs unit testing revealed include cases that were not covered properly, errors in the code, and bugs introduced due to changes in code.

Unit testing immediately revealed some forgotten cases in the initial code, such as:
\begin{itemize}
\item When falsity was in the set of inputs for the proof and model construction, a model was produced rather than the expected proof containing only falsity to show unsatisfibaility.
\item In the case where top (truth) was among many concepts in the list of inputs, an incorrect model with was returned without ensuring all other concepts in the list of inputs were also satisfiable.
\item The possibility of cycles in the input global assumptions was not dealt with by the proof and model construction stage.
\end{itemize}

Some mistakes in code that may have been overlooked without our approach to unit testing:
\begin{itemize}
\item Some incorrect checks performed by the proof checker and model checker.
\item Proofs should deal with set of concepts not containing any duplicates, however, the proof searcher produced a result containing duplicated concepts as a result of applying the proof rule for Exists since a specific case was not considered. This was where the inputs contained:
  \begin{itemize}
    \item An Exists concept stating there exists a successor to a particular relation that satisfies a concept
    \item A Forall concept stating all successors of the same relation must satisfy the same concept specified by the exists concept
  \end{itemize}
\end{itemize}

After some changes to code, some bugs were introduced since the affect of the changes on all cases were not considered. For example:
\begin{itemize}
\item After combining the separate parsers for user input and benchmark files to reuse functions, the parsing for one of the benchmark files was incorrect and needed to have further changes. 
\end{itemize}
