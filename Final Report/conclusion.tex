In this project we created a model/proof searcher as well as a proof and model checkers which were developed independently with the same representation of concepts, models and proofs. The logical framework of our software is $\mathcal{ALC}$ which concepts are based on. 

The technology used in our project consists mainly of Haskell, Happy for the code writing, and Graphviz and Latex for the graphical representation. Through the use of this technology we were able to provide a graphical user interface both for representing models and proofs. We encountered some technical challenges, most vividly the implementation of caching in our program was difficult but was resolved through our frequent meetings.

Using various elements from software developments methods, that suited our program nature, such as the test-driven nature of eXtreme Programming, we minimised risk and allowed the project to adapt to changes quickly. Various tools such as \emph{hlint}, helped in the essential validation process of our program. The mixture of grey-box and black-box testing, and the many unit and global tests (using tools such as Hunit) allowed a high confidence level in our program correctness. 

Apart from this we provided parsers both for user input (for an easier use) and for benchmarks which allowed us to do further tests for our program.

In terms of the learning outcome of this project, we learnt various things, in particular the importance of a complete design in early stages of the project. This design issue is explained is section \ref{sec:valandconc}. For that reason, we would allow spending more time on design then initially given; In particular we would look at the extensions more closely in order to anticipate the need for labelled tableau.

In addition, the vast amount time spend on validation and verification, taught us the difficulty of ensuring correctness of software where it necessary. All group members also learnt various tools such as Graphviz and the Happy parser generator. The coding style was also improved, especially through peer and code reviews of other group members. 

To conclude, the duality between the proof/model searcher and the proof and model checkers, which were developed independently, allows for a much greater confidence for the user. We provide an extensively tested program allowing a user to both search and check the satisfiability of concepts, with multiple modes, which allow for extensive error reports as well as a clear graphical representation. As an extension for this project, more expressive logics can be considered (such as $\mathcal{SHIQ}$ which is simple $\mathcal{ALC}$ plus extended cardinality restrictions and transitive and inverse roles), while keeping the confidence of the user in the program's correctness. We believe that this project could provide a basis for perhaps a more expressive (and hence useful) program while keeping the above mentioned advantages. It could be used in academia (for example in the area of Ontologies and the semantic web) or in industry where formal reasoning about the concepts satisfiability is important. 
