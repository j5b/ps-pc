Our project is focused on reasoning in Description Logic a language
for representing knowlegde. We will provide a short but technical
explanation of what we actually mean by Description Logic. 

There is actually a big family of Description Logics. However the
software deals with one specific case of Description Logic called
$\mathcal{ALC}$ (\textit{Attributive Concept Language with
Complements}) which was introduced first by Manfred Schmidt-Schau$\ss$ 
and Gert Smolka in 1991 \cite{msgs}. Furthermore our software deals
with a restricted form of $\mathcal{ALC}$ with no \textbf{ABOX},
i.e. no statement of truth for givens individuals. $\mathcal{ALC}$ can
be seen both as an more expressive extension of Propositional Logic
and a decidable subset of First Order Logic. Our definitions will
assume that there are no concepts in $\textbf{ABOX}$, so from now on by
$\mathcal{ALC}$ we will refer to its restricted form.

An intuitive way to think about $\mathcal{ALC}$, is that we are given
a set of properties an individual might satisfy and a set of possible
relations between them. Description Logic in $\mathcal{ALC}$ provides
a way to give a representation of knowledge about the individuals,
properties and relations through something called concepts. Examples
of such concepts $\forall Link . Website$, $\exists Friend . (\neg
Internet)$ which can be read as ``every link is to a website'' and
``some friend is not on internet''. We will provide a more precise
definition of all those notions in this section.

Like in other logics $\mathcal{ALC}$'s definition is subdivided in two
parts one syntactic (language) and the other semantic (meaning). We
will first present the syntactic part, then the semantic part and
finally explain the theory about $\mathcal{ALC}$ we have used in our
software, namely knowlegde base, negation normal form and tableau
calculus. For reasons of brieviety and simplicity we shall remain
quite informal. More explicit theory about the following notions can be
found in Schmidt-Schau$\ss$ and Smolka's paper \cite{msgs}.

\subsection{Syntax of $\mathcal{ALC}$}

The syntax is built upon two sets: A set of atomic concept names
(unary relations) and a set of relation names (binary
relations). Those two sets defines the signature. A signature for
instance could be consisting of the following atoms: ``Book'',
``Film''; and the following relations: ``Bought'', ``Borrowed''. We
will now define what a concept is. A concept in $\mathcal{ALC}$ is a
statement of truth and falsity just like formulaes are statements of
truth in First-Order logic.

Anything of the following form is a concept:
\begin{itemize}
\item $\top$ (``truth'', ``tautology''),$\bot$ (``bottom'', ``falsity'') and any atomic concept name $A$ is a concept.
\item If $C$ and $D$ are concepts then $C \sqcap D$ is a concept
  called the intersection (or the conjunction) of $C$ and $D$.
\item If $C$ and $D$ are concepts then $C \sqcup D$ is a concept
  called the union (or the disjunction) of $C$ and $D$.
\item If $C$ is a concept then $\neg C$ is a concept called the complement (or the
  negation) of $C$.
\item If $C$ is a concept and $R$ a relation name then $\forall R . C$
  and $\exists R . C$ is a concept called each respectively the
  universal and existential restriction of $C$.
\end{itemize}

Nothing else is a concept.

\subsection{Semantics of $\mathcal{ALC}$}

The formal semantic for $\mathcal{ALC}$ is defined the notion of
interpretation which gives meaning for Description Logic concepts. An
interpretation is a pair $(\Delta^{I},.^{I})$, where $\Delta^{I}$ is a
non-empty set called the domain and $.^{I}$ is a function sending each
atomic concept to a subset of $\Delta^{I}$ and each relation name to a
subset of $\Delta^{I} \times \Delta^{I}$ and satisfying the following
properties:

\begin{itemize}
\item $\top^{I} = \Delta^{I}$ and $\bot^{I} = \emptyset$.
\item $(C \sqcap D)^{I} = C^{I} \cap D^{I}$.
\item $(C \sqcup D)^{I} = C^{I} \cup D^{I}$.
\item $(\neg C)^{I} = \Delta^{I} \backslash C^{I}$.
\item $(\forall R . C)^{I} = \{x \in \Delta^{I} \text{: forall } (x,y) \in R^{I} \text{ implies } y \in C^{I}\}$ 
\item $(\exists R . C)^{I} = \{x \in \Delta^{I} \text{: exists } (x,y) \in R^{I} \text{ implies } y \in C^{I}\}$ 
\end{itemize}

\subsection{Knowledge bases}

A knowledge base in Description Logic is defined by two collections of
concepts for some signature in $\mathcal{ALC}$. The first one are the
global assumptions often written as $\Gamma$ and we will refer here
as \textit{Gamma} and the second one are the initial set of concepts
which we will refer here as the \textit{Givens}. We say a knowledge
base is satisfiable if there exists an interpretation that makes every
statement in \textit{Gamma} true at each point of $\Delta^{I}$ and
every statement in \textit{Givens} true at some point in
$\Delta^{I}$. In other words if the interpretation of every concept
in \textit{Gamma} is $\Delta^{I}$, and the interpreration of every
concept in \textit{Givens} is a non-empty subset of $\Delta^{I}$ for
some interpretation. Such an interpretation is called a model.  If no
such model exists we say a knowledge base is unsatisfiable. 

For example if \textit{Givens} consists of one concept namely $\exists
R. \top$ and if \textit{Gamma} consists of also one concept only $A$
(an atomic concept name), then this knowledge base is satisfiable
since the intrepretation $\Delta^{I} = \{1\}$ with $A^{I} = \{1\}$ and
$R^{I} = \{(1,1)\}$ is a model. If some global assumptions together
with an initial set of concepts is unsatisfiable, i.e. no model exists
then we can show unsatisfiability through a proof.

\subsection{Negation normal form}

For programming purpose we found it useful to use the notion of
negation normal form (NNF), as it made simpler the implementation of
the algorithms. We say that a concept $C$ is in NNF if for any
subconcept of $C$ of the form $\neg C'$ then $C'$ must be an atomic
name concept.

For any concept $C$ there is a concept $D$ equivalent which is NNF. We
say two concepts are equivalent if their interpretation will always be
the same, regardless of the interpretation. For instance $\neg
(\neg \top)$ is equivalence to $\top$. Using the following set of
equivalences we can get a NNF of a concept $C$.

\begin{itemize}
\item $\neg (\neg C)$ is equivalent to $C$
\item $\neg (C \sqcap D)$ is equivalent to $(\neg C) \sqcap (\neg D)$
\item $\neg (C \sqcup D)$ is equivalent to $(\neg C) \sqcup (\neg D)$
\item $\neg (\exists R . C)$ is equivalent to $\forall R . (\neg C)$
\item $\neg (\forall R . C)$ is equivalent to $\exists R . (\neg C)$
\end{itemize}

For example if we are given a concept $\neg (\exists (\neg (C \sqcap
D)))$, then using the equivalence we can get the concept$\forall
(C \sqcap D)$, which is a NNF of the concept $\neg (\exists (\neg
(C \sqcap D)))$.

We should note that for a given knowledge base $K$, if $I$ is an
interpretation for $K$ then it is also an interpretation to the NNFs
of $K$, since the concepts have the same interpretations. So it 
doesn't ``affect'' model and proof search algorithms.

