The proof theory we use is \emph{Tableaux Calculus}, which is sound and complete
with respect to $\mathcal{ALC}$. There is a tableaux calculus proof of $\bot$ for
a set of global assumptions $\Gamma$ and a set of concepts $X$ if and only if these
are not satisfiable. So this theory allows us to tell exactly when we can provide
a model, or when we can show unsatisfiablity by a formal proof.

Our program uses the theory above to say whether a set of concepts is satisfiable or
not (assuming some global knowledge). If it is, the program provides a model that can
be checked, otherwise it provides a proof, that can also be checked. The main components
of the program are the \textbf{parser}, a \textbf{proof/model searcher} and
both a \textbf{proof checker} and a \textbf{model checker}. The \emph{parser} reads the
user input and translates it into an internal representation of the concepts. Given
such a representation, the \emph{proof/model searcher} provides either a proof or a
model. The \emph{proof checker} and the \emph{model checker} can check these for
correctness and provide useful help in case something is wrong.

Moreover, supply some additional features.
we designed a sophisticated testing framework that allows to test the
program against large sets of formulas -- either read from large files or automatically
generated. We not only provide the default text-based output of proofs and models, but
we can also generate user-friendly graphical representations. The interface we provide
seperates the model/proof searcher from the proof/model checker: users can check there
own proofs, not generated by our searcher.